<!--
GENERATED FILE - DO NOT EDIT
This file was generated by [MarkdownSnippets](https://github.com/SimonCropp/MarkdownSnippets).
Source File: /docs/mdsource/http-passthrough.source.md
To change this file edit the source file and then run MarkdownSnippets.
-->

# SQL HTTP Passthrough

SQL HTTP Passthrough provides a bridge between an HTTP stream (via JavaScript on a web page) and the [SQL Server transport](https://docs.particular.net/transports/sql/). It leverages SQL Transport - Native and [SQL Attachments](https://github.com/NServiceBusExtensions/NServiceBus.Attachments).

<!-- toc -->
## Contents

  * [Design](#design)
    * [Server side hosting](#server-side-hosting)
    * [Deduplication](#deduplication)
    * [Data and attachments](#data-and-attachments)
  * [Usage](#usage)
    * [Server-side](#server-side)
    * [Client - JavaScript](#client---javascript)
    * [Client .NET](#client-net)<!-- endToc -->


## Design


### Server side hosting

SQL HTTP Passthrough is designed to be consumed by any web application built on [ASP.NET Core](https://docs.microsoft.com/en-us/aspnet/core/). For example, it can be used to send a message from a [Controller](https://docs.microsoft.com/en-us/aspnet/core/mvc/controllers/actions), a [BaseController](https://coderwall.com/p/cibprg/basecontroller-in-asp-net-mvc), a [Filter](https://docs.microsoft.com/en-us/aspnet/core/mvc/controllers/filters) or a [Middleware](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/middleware/).


### Deduplication

To handle intermittent connectivity issues it is desirable to have a web client leverage a retry mechanism so if a request fails, the same request can be immediately re-sent. To prevent this resulting in duplicate message being placed on the queue, message deduplication has to occur. SQL HTTP Passthrough leverages the [deduplication feature](/transports/sql/sql-native.md#Deduplication) of SQL Transport - Native.


### Data and attachments

To send both message content and associated binary data (attachments) a [multipart form](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Disposition) is used.


## Usage


### Server-side


#### ASP.NET Core startup

At [ASP.NET Core startup](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/startup) several actions are taken:

 * `AddSqlHttpPassthrough` is called on [IServiceCollection](https://docs.microsoft.com/en-us/dotnet/api/microsoft.extensions.dependencyinjection.iservicecollection) which makes the `ISqlPassthrough` interface available via [dependency injection](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection).
 * `AddSqlHttpPassthroughBadRequestMiddleware` is called on [IApplicationBuilder](https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.iapplicationbuilder), which adds [Middleware](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/middleware/) to the pipeline. This means that if the request parsing code of the SQL HTTP Passthrough throws a `BadRequestException`, that exception can be gracefully handled and an [HTTP BadRequest (400)](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/400) can be sent as a response. This is optional, and a Controller can choose to explicitly catch and handle `BadRequestException` in a different way.

<!-- snippet: Startup -->
<a id='snippet-startup'></a>
```cs
public class Startup
{
    public void ConfigureServices(IServiceCollection services)
    {
        var configuration = new PassthroughConfiguration(
            connectionFunc: OpenConnection,
            callback: Callback,
            dedupCriticalError: exception =>
            {
                Environment.FailFast("Dedup cleanup failure", exception);
            });
        services.AddSqlHttpPassthrough(configuration);
        services.AddMvcCore();
        // other ASP.MVC config
    }

    Task<Table> Callback(HttpContext httpContext, PassthroughMessage message)
    {
        //TODO: validate that the message type is allowed
        //TODO: validate that the destination is allowed
        if (message.Destination == null)
        {
            var customDestination = new Table("Custom");
            return Task.FromResult(customDestination);
        }

        var destination = new Table(message.Destination);
        return Task.FromResult(destination);
    }

    public void Configure(IApplicationBuilder builder)
    {
        builder.AddSqlHttpPassthroughBadRequestMiddleware();
        builder.UseMvc();
        // other ASP.MVC config
    }

    Task<DbConnection> OpenConnection(CancellationToken cancellation)
    {
        //TODO open and return a SqlConnection
        return null!;
    }
}
```
<sup><a href='/src/SqlServer.Native.Tests/HttpPassthrough/Snippets/Startup.cs#L11-L57' title='Snippet source file'>snippet source</a> | <a href='#snippet-startup' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


##### Append Claims

Append the [Claims](https://msdn.microsoft.com/en-us/library/system.security.claims.claim.aspx) of the [ClaimsPrincipal](https://msdn.microsoft.com/en-us/library/system.security.claims.claimsprincipal.aspx) from [HttpContext.User](https://msdn.microsoft.com/en-us/library/system.web.httpcontext.user.aspx) to the headers of the outgoing message. 

By default each header will get a prefix of `SqlHttpPassthrough.Claim.`

<!-- snippet: AppendClaimsToMessageHeaders -->
<a id='snippet-appendclaimstomessageheaders'></a>
```cs
var configuration = new PassthroughConfiguration(
    connectionFunc: OpenConnection,
    callback: Callback,
    dedupCriticalError: exception =>
    {
        Environment.FailFast("Dedup cleanup failure", exception);
    });
configuration.AppendClaimsToMessageHeaders();
services.AddSqlHttpPassthrough(configuration);
```
<sup><a href='/src/SqlServer.Native.Tests/HttpPassthrough/Snippets/AppendClaimsToMessageHeaders.cs#L36-L48' title='Snippet source file'>snippet source</a> | <a href='#snippet-appendclaimstomessageheaders' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->

A custom prefix can also be defined.

<!-- snippet: AppendClaimsToMessageHeaders_WithPrefix -->
<a id='snippet-appendclaimstomessageheaders_withprefix'></a>
```cs
var configuration = new PassthroughConfiguration(
    connectionFunc: OpenConnection,
    callback: Callback,
    dedupCriticalError: exception =>
    {
        Environment.FailFast("Dedup cleanup failure", exception);
    });
configuration.AppendClaimsToMessageHeaders(headerPrefix: "Claim.");
services.AddSqlHttpPassthrough(configuration);
```
<sup><a href='/src/SqlServer.Native.Tests/HttpPassthrough/Snippets/AppendClaimsToMessageHeaders.cs#L19-L31' title='Snippet source file'>snippet source</a> | <a href='#snippet-appendclaimstomessageheaders_withprefix' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->

For unit testing and integration purposes it may be useful to manipulate a raw `Dictionary<string, string>`. This can be done using `ClaimsAppender`.

To append claims:

<!-- snippet: AppendClaimsToDictionary -->
<a id='snippet-appendclaimstodictionary'></a>
```cs
var claims = new List<Claim>
{
    new Claim(ClaimTypes.Email, "User@foo.bar"),
    new Claim(ClaimTypes.NameIdentifier, "User1"),
    new Claim(ClaimTypes.NameIdentifier, "User2")
};
ClaimsAppender.Append(claims, headerDictionary, "prefix.");
```
<sup><a href='/src/SqlServer.Native.Tests/HttpPassthrough/Snippets/AppendClaimsToMessageHeaders.cs#L53-L63' title='Snippet source file'>snippet source</a> | <a href='#snippet-appendclaimstodictionary' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->

To extract claims:

<!-- snippet: ExtractClaimsFromDictionary -->
<a id='snippet-extractclaimsfromdictionary'></a>
```cs
var claimsList = ClaimsAppender.Extract(headerDictionary, "prefix.");
```
<sup><a href='/src/SqlServer.Native.Tests/HttpPassthrough/Snippets/AppendClaimsToMessageHeaders.cs#L68-L72' title='Snippet source file'>snippet source</a> | <a href='#snippet-extractclaimsfromdictionary' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->

It may also be necessary to process claims with no reference to `NServiceBus.SqlServer.HttpPassthrough`. This can be done using the following utility methods. Note that these methods use `JsonConvert` from [Json.NET](https://www.newtonsoft.com/json).

<!-- snippet: ClaimsRaw -->
<a id='snippet-claimsraw'></a>
```cs
public static void Append(
    IEnumerable<Claim> claims,
    IDictionary<string, string> headers, string prefix)
{
    foreach (var claim in claims.GroupBy(x => x.Type))
    {
        var items = claim.Select(x => x.Value);
        headers.Add(prefix + claim.Key, JsonConvert.SerializeObject(items));
    }
}

public static IEnumerable<Claim> Extract(
    IDictionary<string, string> headers,
    string prefix)
{
    foreach (var header in headers)
    {
        var key = header.Key;
        if (!key.StartsWith(prefix))
        {
            continue;
        }

        key = key.Substring(prefix.Length, key.Length - prefix.Length);
        var list = JsonConvert.DeserializeObject<List<string>>(header.Value);
        foreach (var value in list)
        {
            yield return new Claim(key, value);
        }
    }
}
```
<sup><a href='/src/SqlServer.Native.Tests/HttpPassthrough/Snippets/AppendClaimsToMessageHeaders.cs#L76-L110' title='Snippet source file'>snippet source</a> | <a href='#snippet-claimsraw' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


##### Message callback

`AddSqlHttpPassthrough` takes a required parameter `callback` with the signature `Func<HttpContext, PassthroughMessage, Task<Table>>`. This delegate will be called during each request-to-message execution. This occurs after the HTTP request has been parsed, and before the outgoing message is placed on the SQL table. The return value is a `Table` that dictates the SQL table and schema that the message will be written to.

While callback supports async, via returning a `Task<Table>`, any required async action should have its result cached so as not to slow down subsequent requests. For example, it may be necessary to perform authorization in a callback. The result of this authorization should be cached for some period of time, and the cached result should be purged when permissions are changed.

The message callback can be used for several purposes:

* Validate that the message type and destination are allowed.
* Add extra headers to the outgoing message.
* Manipulate any other properties of the outgoing message

WARNING: Note that a "trust but verify" approach should be taken in regards to the HTTP client. The combination of message type/namespace and destination should be verified against a known allowed list.


`PassthroughMessage` contains the following properties:

 * Id: Contains the `MessageId` value from `HttpRequest.Headers`
 * CorrelationId: Contains the `MessageId` value from `HttpRequest.Headers`
 * Type: Contains the `MessageType` value from `HttpRequest.Headers`. Will be combined with `Namespace` and used for the `NServiceBus.EnclosedMessageTypes` header.
 * Namespace: Contains the `MessageNamespace` value from `HttpRequest.Headers`. Will be combined with `Type` and used for the `NServiceBus.EnclosedMessageTypes` header.
 * Body: Contains the `Message` value from the `IFormCollection`.
 * Destination: Contains the 'Destination' value from `HttpRequest.Headers`. Primarily used to convert to a `Table` as a return value for the passthrough callback.
 * ClientUrl: The URL of the submitting page. Contains the `HeaderNames.Referer` value from `HttpRequest.Headers`. Will be written to a header `MessagePassthrough.ClientUrl` in the outgoing NServiceBus message.
 * Attachments: Contains all binaries extracted from `IFormCollection.Files`
 * ExtraHeaders: Any extra headers to add to the outgoing NServiceBus message.


#### Usage in a controller

Usage in a [controller](https://docs.microsoft.com/en-us/aspnet/core/mvc/controllers/actions) consists of several parts.

 * `ISqlPassthrough` injected through [dependency injection](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection).
 * The Controller handling the HTTP Post and passing that information to `ISqlPassthrough.Send`.

<!-- snippet: Controller -->
<a id='snippet-controller'></a>
```cs
[Route("SendMessage")]
public class PassthroughController : ControllerBase
{
    ISqlPassthrough sender;

    public PassthroughController(ISqlPassthrough sender)
    {
        this.sender = sender;
    }

    [HttpPost]
    public Task Post(CancellationToken cancellation)
    {
        return sender.Send(HttpContext, cancellation);
    }
}
```
<sup><a href='/src/SqlServer.Native.Tests/HttpPassthrough/Snippets/PassThroughController.cs#L6-L25' title='Snippet source file'>snippet source</a> | <a href='#snippet-controller' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->

WARNING: In a production application the controller would be performing any authorization and authentication on the incoming request. 


#### Exception behavior

If `ISqlPassthrough` fails to send, a `SendFailureException` will be thrown containing all context in a `PassthroughMessage` property.

If the incoming HTTP request fails to be parsed, a `BadRequestException` will be thrown with the message containing the reason for the failure.


### Client - JavaScript 


#### Form submission

The JavaScript that submits the data does so through by building up a [FormData](https://developer.mozilla.org/en-US/docs/Web/API/FormData) object and [POSTing](https://developer.mozilla.org/en-US/docs/Learn/HTML/Forms/Sending_and_retrieving_form_data#The_POST_method) that via the [Fetch API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API).

<!-- snippet: PostToBus -->
<a id='snippet-posttobus'></a>
```html
function PostToBus() {
    var message = new Object();
    message.Property1 = document.getElementById("property1").value;
    message.Property2 = document.getElementById("property2").value;
    var jsonString = JSON.stringify(message);

    var data = new FormData();
    var files = document.getElementById("files").files;
    for (var i = 0; i < files.length; i++) {
        data.append('files[]', files[i], files[i].name);
    }
    data.append("message", jsonString);

    var postSettings = {
        method: 'POST',
        credentials: 'include',
        mode: 'cors',
        headers: {
            'MessageType': 'SampleMessage',
            'MessageNamespace': 'SampleNamespace',
            'MessageId': newGuid(),
            'Destination': 'Endpoint'
        },
        body: data
    };

    return fetch('SendMessage', postSettings);
}
```
<sup><a href='/src/SqlServer.Native.Tests/HttpPassthrough/Snippets/Usage.html#L11-L40' title='Snippet source file'>snippet source</a> | <a href='#snippet-posttobus' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


#### MessageId generation

For deduplication to operate, the client must generate a [MessageId](/nservicebus/messaging/message-identity.md), so that any retries can be ignored. JavaScript does not contain native functionality to generate a GUID, so a helper method is used. 

<!-- snippet: Guid -->
<a id='snippet-guid'></a>
```html
function newGuid() {
    return ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, c =>
        (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4)
            .toString(16)
            .toUpperCase()
    )
}
```
<sup><a href='/src/SqlServer.Native.Tests/HttpPassthrough/Snippets/Usage.html#L1-L9' title='Snippet source file'>snippet source</a> | <a href='#snippet-guid' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


### Client .NET

Creating and posting a multipart form can be done using a combination of [MultipartFormDataContent](https://msdn.microsoft.com/en-us/library/system.net.http.multipartformdatacontent.aspx) and [HttpClient.PostAsync](https://msdn.microsoft.com/en-us/library/system.net.http.httpclient.postasync.aspx). To simplify this action the `ClientFormSender` class can be used:

<!-- snippet: ClientFormSender -->
<a id='snippet-clientformsender'></a>
```cs
var clientFormSender = new ClientFormSender(httpClient);
await clientFormSender.Send(
    route: "/SendMessage",
    message: "{\"Property\": \"Value\"}",
    typeName: "TheMessageType",
    typeNamespace: "TheMessageNamespace",
    destination: "TheDestination",
    attachments: new Dictionary<string, byte[]>
    {
        {"fileName", Encoding.UTF8.GetBytes("fileContents")}
    });
```
<sup><a href='/src/SqlServer.Native.Tests/HttpPassthrough/Snippets/Usage.cs#L13-L27' title='Snippet source file'>snippet source</a> | <a href='#snippet-clientformsender' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->

This can be useful when performing [Integration testing in ASP.NET Core](https://docs.microsoft.com/en-us/aspnet/core/testing/integration-testing).

<!-- snippet: asptesthost -->
<a id='snippet-asptesthost'></a>
```cs
var hostBuilder = new WebHostBuilder();
hostBuilder.UseStartup<Startup>();
using var testServer = new TestServer(hostBuilder);
using var httpClient = testServer.CreateClient();
var clientFormSender = new ClientFormSender(httpClient);
await clientFormSender.Send(
    route: "/SendMessage",
    message: "{\"Property\": \"Value\"}",
    typeName: "TheMessageType",
    typeNamespace: "TheMessageNamespace",
    destination: "TheDestination",
    attachments: new Dictionary<string, byte[]>
    {
        {"fileName", Encoding.UTF8.GetBytes("fileContents")}
    });
```
<sup><a href='/src/SqlServer.Native.Tests/HttpPassthrough/Snippets/Usage.cs#L32-L50' title='Snippet source file'>snippet source</a> | <a href='#snippet-asptesthost' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->
