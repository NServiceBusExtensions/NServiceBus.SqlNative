<!--
GENERATED FILE - DO NOT EDIT
This file was generated by [MarkdownSnippets](https://github.com/SimonCropp/MarkdownSnippets).
Source File: /readme.source.md
To change this file edit the source file and then run MarkdownSnippets.
-->

# <img src="/src/icon.png" height="30px"> NServiceBus.SqlServer.Native

[![Build status](https://ci.appveyor.com/api/projects/status/vlhu32bab9gk2olc/branch/main?svg=true)](https://ci.appveyor.com/project/SimonCropp/nservicebus-sqlnative)
[![NuGet Status](https://img.shields.io/nuget/v/NServiceBus.SqlServer.Native.svg?label=SqlServer.Native)](https://www.nuget.org/packages/NServiceBus.SqlServer.Native/)
[![NuGet Status](https://img.shields.io/nuget/v/NServiceBus.SqlServer.HttpPassthrough.svg?label=SqlServer.HttpPassthrough)](https://www.nuget.org/packages/NServiceBus.SqlServer.HttpPassthrough/)
[![NuGet Status](https://img.shields.io/nuget/v/NServiceBus.SqlServer.Deduplication.svg?label=SqlServer.Deduplication)](https://www.nuget.org/packages/NServiceBus.SqlServer.Deduplication/)

SQL Server Transport Native is a shim providing low-level access to the [NServiceBus SQL Server Transport](https://docs.particular.net/transports/sql/) with no NServiceBus or SQL Server Transport reference required.

**See [Milestones](../../milestones?state=closed) for release notes.**

<!--- StartOpenCollectiveBackers -->

[Already a Patron? skip past this section](#endofbacking)


## Community backed

**It is expected that all developers either [become a Patron](https://opencollective.com/nservicebusextensions/contribute/patron-6976) to use NServiceBusExtensions. [Go to licensing FAQ](https://github.com/NServiceBusExtensions/Home/#licensingpatron-faq)**


### Sponsors

Support this project by [becoming a Sponsor](https://opencollective.com/nservicebusextensions/contribute/sponsor-6972). The company avatar will show up here with a website link. The avatar will also be added to all GitHub repositories under the [NServiceBusExtensions organization](https://github.com/NServiceBusExtensions).


### Patrons

Thanks to all the backing developers. Support this project by [becoming a patron](https://opencollective.com/nservicebusextensions/contribute/patron-6976).

<img src="https://opencollective.com/nservicebusextensions/tiers/patron.svg?width=890&avatarHeight=60&button=false">

<a href="#" id="endofbacking"></a>

<!--- EndOpenCollectiveBackers -->


<!-- toc -->
## Contents

  * [Usage scenarios](#usage-scenarios)
  * [Main Queue](#main-queue)
    * [Queue management](#queue-management)
    * [Sending messages](#sending-messages)
    * [Reading messages](#reading-messages)
    * [Consuming messages](#consuming-messages)
  * [Delayed Queue](#delayed-queue)
    * [Queue management](#queue-management-1)
    * [Sending messages](#sending-messages-1)
    * [Reading messages](#reading-messages-1)
    * [Consuming messages](#consuming-messages-1)
  * [Headers](#headers)
  * [Subscriptions](#subscriptions)
    * [Table management](#table-management)
  * [Deduplication](#deduplication)
    * [Table management](#table-management-1)
    * [Sending messages](#sending-messages-2)
    * [Deduplication cleanup](#deduplication-cleanup)
    * [JSON headers](#json-headers)
    * [Copied header constants](#copied-header-constants)
    * [Duplicated timestamp functionality](#duplicated-timestamp-functionality)
  * [ConnectionHelpers](#connectionhelpers)
  * [SqlServer.HttpPassthrough](#sqlserverhttppassthrough)<!-- endToc -->


## NuGet packages

 * https://nuget.org/packages/NServiceBus.SqlServer.Native/
 * https://nuget.org/packages/NServiceBus.SqlServer.HttpPassthrough/
 * https://nuget.org/packages/NServiceBus.SqlServer.Deduplication/


## Usage scenarios

 * **Error or Audit queue handling**: Allows to consume messages from error and audit queues, for example to move them to a long-term archive. NServiceBus expects to have a queue per message type, so NServiceBus endpoints are not suitable for processing error or audit queues. SQL Native allows manipulation or consumption of queues containing multiple types of messages.
 * **Corrupted or malformed messages**: Allows to process poison messages which can't be deserialized by NServiceBus. In SQL Native message headers and body are treated as a raw string and byte array, so corrupted or malformed messages can be read and manipulated in code to correct any problems.
 * **Deployment or decommission**: Allows to perform common operational activities, similar to [operations scripts](https://docs.particular.net/transports/sql/operations-scripting#native-send-the-native-send-helper-methods-in-c). Running [installers](https://docs.particular.net/nservicebus/operations/installers) requires starting a full endpoint. This is not always ideal during the execution of a deployment or decommission. SQL Native allows creating or deleting of queues with no running endpoint, and with significantly less code. This also makes it a better candidate for usage in deployment scripting languages like PowerShell.
 * **Bulk operations**: SQL Native supports sending and receiving of multiple messages within a single `SQLConnection` and `SQLTransaction`.
 * **Explicit connection and transaction management**: NServiceBus abstracts the `SQLConnection` and `SQLTransaction` creation and management. SQL Native allows any consuming code to manage the scope and settings of both the `SQLConnection` and `SQLTransaction`.
 * **Message pass through**: SQL Native reduces the amount of boilerplate code and simplifies development.


## Main Queue


### Queue management

Queue management for the [native delayed delivery](https://docs.particular.net/transports/sql/native-delayed-delivery) functionality.

See also [SQL Server Transport - SQL statements](https://docs.particular.net/transports/sql/sql-statements#installation).


#### Create

The queue can be created using the following:

<!-- snippet: CreateQueue -->
<a id='snippet-CreateQueue'></a>
```cs
var manager = new QueueManager("endpointTable", sqlConnection);
await manager.Create();
```
<sup><a href='/src/SqlServer.Native.Tests/Snippets/Main/MainQueue.cs#L11-L16' title='Snippet source file'>snippet source</a> | <a href='#snippet-CreateQueue' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


#### Delete

The queue can be deleted using the following:

<!-- snippet: DeleteQueue -->
<a id='snippet-DeleteQueue'></a>
```cs
var manager = new QueueManager("endpointTable", sqlConnection);
await manager.Drop();
```
<sup><a href='/src/SqlServer.Native.Tests/Snippets/Main/MainQueue.cs#L21-L26' title='Snippet source file'>snippet source</a> | <a href='#snippet-DeleteQueue' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


### Sending messages

Sending to the main transport queue.


#### Single

Sending a single message.

<!-- snippet: Send -->
<a id='snippet-Send'></a>
```cs
var manager = new QueueManager("endpointTable", sqlConnection);
var message = new OutgoingMessage(
    id: Guid.NewGuid(),
    headers: headers,
    bodyBytes: body);
await manager.Send(message);
```
<sup><a href='/src/SqlServer.Native.Tests/Snippets/Main/MainQueue.cs#L34-L43' title='Snippet source file'>snippet source</a> | <a href='#snippet-Send' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


#### Batch

Sending a batch of messages.

<!-- snippet: SendBatch -->
<a id='snippet-SendBatch'></a>
```cs
var manager = new QueueManager("endpointTable", sqlConnection);
var messages = new List<OutgoingMessage>
{
    new(
        id: Guid.NewGuid(),
        headers: headers1,
        bodyBytes: body1),
    new(
        id: Guid.NewGuid(),
        headers: headers2,
        bodyBytes: body2),
};
await manager.Send(messages);
```
<sup><a href='/src/SqlServer.Native.Tests/Snippets/Main/MainQueue.cs#L54-L70' title='Snippet source file'>snippet source</a> | <a href='#snippet-SendBatch' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


### Reading messages

"Reading" a message returns the data from the database without deleting it.


#### Single

Reading a single message.

<!-- snippet: Read -->
<a id='snippet-Read'></a>
```cs
var manager = new QueueManager("endpointTable", sqlConnection);
var message = await manager.Read(rowVersion: 10);

if (message != null)
{
    Console.WriteLine(message.Headers);
    if (message.Body != null)
    {
        using var reader = new StreamReader(message.Body);
        var bodyText = await reader.ReadToEndAsync();
        Console.WriteLine(bodyText);
    }
}
```
<sup><a href='/src/SqlServer.Native.Tests/Snippets/Main/MainQueue.cs#L75-L91' title='Snippet source file'>snippet source</a> | <a href='#snippet-Read' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


#### Batch

Reading a batch of messages.

<!-- snippet: ReadBatch -->
<a id='snippet-ReadBatch'></a>
```cs
var manager = new QueueManager("endpointTable", sqlConnection);
var result = await manager.Read(
    size: 5,
    startRowVersion: 10,
    func: async (message, cancel) =>
    {
        Console.WriteLine(message.Headers);
        if (message.Body == null)
        {
            return;
        }

        using var reader = new StreamReader(message.Body);
        var bodyText = await reader.ReadToEndAsync(cancel);
        Console.WriteLine(bodyText);
    });

Console.WriteLine(result.Count);
Console.WriteLine(result.LastRowVersion);
```
<sup><a href='/src/SqlServer.Native.Tests/Snippets/Main/MainQueue.cs#L96-L118' title='Snippet source file'>snippet source</a> | <a href='#snippet-ReadBatch' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


#### RowVersion tracking

For many scenarios, it is likely to be necessary to keep track of the last message `RowVersion` that was read. A lightweight implementation of the functionality is provided by `RowVersionTracker`. `RowVersionTracker` stores the current `RowVersion` in a table containing a single column and row.

<!-- snippet: RowVersionTracker -->
<a id='snippet-RowVersionTracker'></a>
```cs
var versionTracker = new RowVersionTracker();

// create table
await versionTracker.CreateTable(sqlConnection);

// save row version
await versionTracker.Save(sqlConnection, newRowVersion);

// get row version
var startingRow = await versionTracker.Get(sqlConnection);
```
<sup><a href='/src/SqlServer.Native.Tests/Snippets/Main/ProcessingLoop.cs#L14-L27' title='Snippet source file'>snippet source</a> | <a href='#snippet-RowVersionTracker' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->

Note that this is only one possible implementation of storing the current `RowVersion`.


#### Processing loop

For scenarios where continual processing (reading and executing some code with the result) of incoming messages is required, `MessageProcessingLoop` can be used. 

An example use case is monitoring an [error queue](https://docs.particular.net/nservicebus/recoverability/configure-error-handling). Some action should be taken when a message appears in the error queue, but it should remain in that queue in case it needs to be retried. 

Note that in the below snippet, the above `RowVersionTracker` is used for tracking the current `RowVersion`.

<!-- snippet: ProcessingLoop -->
<a id='snippet-ProcessingLoop'></a>
```cs
var rowVersionTracker = new RowVersionTracker();

var startingRow = await rowVersionTracker.Get(sqlConnection);

static async Task Callback(
    SqlTransaction transaction,
    IncomingMessage message,
    Cancel cancel)
{
    if (message.Body == null)
    {
        return;
    }

    using var reader = new StreamReader(message.Body);
    var bodyText = await reader.ReadToEndAsync(cancel);
    Console.WriteLine($"Message received in error message:\r\n{bodyText}");
}

static void ErrorCallback(Exception exception) =>
    Environment.FailFast("Message processing loop failed", exception);

Task<SqlTransaction> BuildTransaction(Cancel cancel) =>
    ConnectionHelpers.BeginTransaction(connectionString, cancel);

Task PersistRowVersion(
    SqlTransaction transaction,
    long rowVersion,
    Cancel cancel) =>
    rowVersionTracker.Save(sqlConnection, rowVersion, cancel);

var processingLoop = new MessageProcessingLoop(
    table: "error",
    delay: TimeSpan.FromSeconds(1),
    transactionBuilder: BuildTransaction,
    callback: Callback,
    errorCallback: ErrorCallback,
    startingRow: startingRow,
    persistRowVersion: PersistRowVersion);
processingLoop.Start();

Console.ReadKey();

await processingLoop.Stop();
```
<sup><a href='/src/SqlServer.Native.Tests/Snippets/Main/ProcessingLoop.cs#L32-L79' title='Snippet source file'>snippet source</a> | <a href='#snippet-ProcessingLoop' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


### Consuming messages

"Consuming" a message returns the data from the database and also deletes that message.


#### Single

Consume a single message.

<!-- snippet: Consume -->
<a id='snippet-Consume'></a>
```cs
var manager = new QueueManager("endpointTable", sqlConnection);
var message = await manager.Consume();

if (message != null)
{
    Console.WriteLine(message.Headers);
    if (message.Body != null)
    {
        using var reader = new StreamReader(message.Body);
        var bodyText = await reader.ReadToEndAsync();
        Console.WriteLine(bodyText);
    }
}
```
<sup><a href='/src/SqlServer.Native.Tests/Snippets/Main/MainQueue.cs#L123-L139' title='Snippet source file'>snippet source</a> | <a href='#snippet-Consume' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


#### Batch

Consuming a batch of messages.

<!-- snippet: ConsumeBatch -->
<a id='snippet-ConsumeBatch'></a>
```cs
var manager = new QueueManager("endpointTable", sqlConnection);
var result = await manager.Consume(
    size: 5,
    func: async (message, cancel) =>
    {
        Console.WriteLine(message.Headers);
        if (message.Body == null)
        {
            return;
        }

        using var reader = new StreamReader(message.Body);
        var bodyText = await reader.ReadToEndAsync(cancel);
        Console.WriteLine(bodyText);
    });

Console.WriteLine(result.Count);
Console.WriteLine(result.LastRowVersion);
```
<sup><a href='/src/SqlServer.Native.Tests/Snippets/Main/MainQueue.cs#L144-L165' title='Snippet source file'>snippet source</a> | <a href='#snippet-ConsumeBatch' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


#### Consuming loop

For scenarios where continual consumption (consuming and executing some code with the result) of incoming messages is required, `MessageConsumingLoop` can be used.

An example use case is monitoring an [audit queue](https://docs.particular.net/nservicebus/operations/auditing). Some action should be taken when a message appears in the audit queue, and it should be purged from the queue to free up the storage space. 

<!-- snippet: ConsumeLoop -->
<a id='snippet-ConsumeLoop'></a>
```cs
static async Task Callback(
    SqlTransaction transaction,
    IncomingMessage message,
    Cancel cancel)
{
    if (message.Body != null)
    {
        using var reader = new StreamReader(message.Body);
        var bodyText = await reader.ReadToEndAsync(cancel);
        Console.WriteLine($"Reply received:\r\n{bodyText}");
    }
}

Task<SqlTransaction> BuildTransaction(Cancel cancel) =>
    ConnectionHelpers.BeginTransaction(connectionString, cancel);

static void ErrorCallback(Exception exception) =>
    Environment.FailFast("Message consuming loop failed", exception);

// start consuming
var consumingLoop = new MessageConsumingLoop(
    table: "endpointTable",
    delay: TimeSpan.FromSeconds(1),
    transactionBuilder: BuildTransaction,
    callback: Callback,
    errorCallback: ErrorCallback);
consumingLoop.Start();

// stop consuming
await consumingLoop.Stop();
```
<sup><a href='/src/SqlServer.Native.Tests/Snippets/Main/ConsumingLoop.cs#L11-L44' title='Snippet source file'>snippet source</a> | <a href='#snippet-ConsumeLoop' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


## Delayed Queue


### Queue management

Queue management for the [native delayed delivery](https://docs.particular.net/transports/sql/native-delayed-delivery) functionality.

See also [SQL Server Transport - SQL statements](https://docs.particular.net/transports/sql/sql-statements#create-delayed-queue-table).


#### Create

The queue can be created using the following:

<!-- snippet: CreateDelayedQueue -->
<a id='snippet-CreateDelayedQueue'></a>
```cs
var manager = new DelayedQueueManager("endpointTable.Delayed", sqlConnection);
await manager.Create();
```
<sup><a href='/src/SqlServer.Native.Tests/Snippets/Delayed/DelayedQueue.cs#L12-L17' title='Snippet source file'>snippet source</a> | <a href='#snippet-CreateDelayedQueue' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


#### Delete

The queue can be deleted using the following:

<!-- snippet: DeleteDelayedQueue -->
<a id='snippet-DeleteDelayedQueue'></a>
```cs
var manager = new DelayedQueueManager("endpointTable.Delayed", sqlConnection);
await manager.Drop();
```
<sup><a href='/src/SqlServer.Native.Tests/Snippets/Delayed/DelayedQueue.cs#L22-L27' title='Snippet source file'>snippet source</a> | <a href='#snippet-DeleteDelayedQueue' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


### Sending messages


#### Single

Sending a single message.

<!-- snippet: SendDelayed -->
<a id='snippet-SendDelayed'></a>
```cs
var manager = new DelayedQueueManager("endpointTable.Delayed", sqlConnection);
var message = new OutgoingDelayedMessage(
    due: DateTime.UtcNow.AddDays(1),
    headers: headers,
    bodyBytes: body);
await manager.Send(message);
```
<sup><a href='/src/SqlServer.Native.Tests/Snippets/Delayed/DelayedQueue.cs#L35-L44' title='Snippet source file'>snippet source</a> | <a href='#snippet-SendDelayed' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


#### Batch

Sending a batch of messages.

<!-- snippet: SendDelayedBatch -->
<a id='snippet-SendDelayedBatch'></a>
```cs
var manager = new DelayedQueueManager("endpointTable.Delayed", sqlConnection);
var messages = new List<OutgoingDelayedMessage>
{
    new(
        due: DateTime.UtcNow.AddDays(1),
        headers: headers1,
        bodyBytes: body1),
    new(
        due: DateTime.UtcNow.AddDays(1),
        headers: headers2,
        bodyBytes: body2),
};
await manager.Send(messages);
```
<sup><a href='/src/SqlServer.Native.Tests/Snippets/Delayed/DelayedQueue.cs#L54-L70' title='Snippet source file'>snippet source</a> | <a href='#snippet-SendDelayedBatch' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


### Reading messages

"Reading" a message returns the data from the database without deleting it.


#### Single

Reading a single message.

<!-- snippet: ReadDelayed -->
<a id='snippet-ReadDelayed'></a>
```cs
var manager = new DelayedQueueManager("endpointTable", sqlConnection);
var message = await manager.Read(rowVersion: 10);

if (message != null)
{
    Console.WriteLine(message.Headers);
    if (message.Body != null)
    {
        using var reader = new StreamReader(message.Body);
        var bodyText = await reader.ReadToEndAsync();
        Console.WriteLine(bodyText);
    }
}
```
<sup><a href='/src/SqlServer.Native.Tests/Snippets/Delayed/DelayedQueue.cs#L75-L91' title='Snippet source file'>snippet source</a> | <a href='#snippet-ReadDelayed' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


#### Batch

Reading a batch of messages.

<!-- snippet: ReadDelayedBatch -->
<a id='snippet-ReadDelayedBatch'></a>
```cs
var manager = new DelayedQueueManager("endpointTable", sqlConnection);
var result = await manager.Read(
    size: 5,
    startRowVersion: 10,
    func: async (message, cancel) =>
    {
        Console.WriteLine(message.Headers);
        if (message.Body == null)
        {
            return;
        }

        using var reader = new StreamReader(message.Body);
        var bodyText = await reader.ReadToEndAsync(cancel);
        Console.WriteLine(bodyText);
    });

Console.WriteLine(result.Count);
Console.WriteLine(result.LastRowVersion);
```
<sup><a href='/src/SqlServer.Native.Tests/Snippets/Delayed/DelayedQueue.cs#L96-L118' title='Snippet source file'>snippet source</a> | <a href='#snippet-ReadDelayedBatch' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


### Consuming messages

"Consuming" a message returns the data from the database and also deletes that message.


#### Single

Consume a single message.

<!-- snippet: ConsumeDelayed -->
<a id='snippet-ConsumeDelayed'></a>
```cs
var manager = new DelayedQueueManager("endpointTable", sqlConnection);
var message = await manager.Consume();

if (message != null)
{
    Console.WriteLine(message.Headers);
    if (message.Body != null)
    {
        using var reader = new StreamReader(message.Body);
        var bodyText = await reader.ReadToEndAsync();
        Console.WriteLine(bodyText);
    }
}
```
<sup><a href='/src/SqlServer.Native.Tests/Snippets/Delayed/DelayedQueue.cs#L123-L139' title='Snippet source file'>snippet source</a> | <a href='#snippet-ConsumeDelayed' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


#### Batch

Consuming a batch of messages.

<!-- snippet: ConsumeDelayedBatch -->
<a id='snippet-ConsumeDelayedBatch'></a>
```cs
var manager = new DelayedQueueManager("endpointTable", sqlConnection);
var result = await manager.Consume(
    size: 5,
    func: async (message, cancel) =>
    {
        Console.WriteLine(message.Headers);
        if (message.Body == null)
        {
            return;
        }

        using var reader = new StreamReader(message.Body);
        var bodyText = await reader.ReadToEndAsync(cancel);
        Console.WriteLine(bodyText);
    });

Console.WriteLine(result.Count);
Console.WriteLine(result.LastRowVersion);
```
<sup><a href='/src/SqlServer.Native.Tests/Snippets/Delayed/DelayedQueue.cs#L144-L165' title='Snippet source file'>snippet source</a> | <a href='#snippet-ConsumeDelayedBatch' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


## Headers

There is a headers helpers class `NServiceBus.Transport.SqlServerNative.Headers`.

It contains several [header](https://docs.particular.net/nservicebus/messaging/headers) related utilities.


## Subscriptions

Queue management for the [native publish subscribe](https://docs.particular.net/transports/sql/native-publish-subscribe) functionality.


### Table management


#### Create

The table can be created using the following:

<!-- snippet: CreateSubscriptionTable -->
<a id='snippet-CreateSubscriptionTable'></a>
```cs
var manager = new SubscriptionManager("SubscriptionRouting", sqlConnection);
await manager.Create();
```
<sup><a href='/src/SqlServer.Native.Tests/Snippets/Subscription/Subscription.cs#L11-L16' title='Snippet source file'>snippet source</a> | <a href='#snippet-CreateSubscriptionTable' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


#### Delete

The table can be deleted using the following:

<!-- snippet: DeleteSubscriptionTable -->
<a id='snippet-DeleteSubscriptionTable'></a>
```cs
var manager = new SubscriptionManager("SubscriptionRouting", sqlConnection);
await manager.Drop();
```
<sup><a href='/src/SqlServer.Native.Tests/Snippets/Subscription/Subscription.cs#L21-L26' title='Snippet source file'>snippet source</a> | <a href='#snippet-DeleteSubscriptionTable' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


## Deduplication

Some scenarios, such as HTTP message pass through, require message deduplication.


### Table management


#### Create

The table can be created using the following:

<!-- snippet: CreateDeduplicationTable -->
<a id='snippet-CreateDeduplicationTable'></a>
```cs
var manager = new DedupeManager(sqlConnection, "DeduplicationTable");
await manager.Create();
```
<sup><a href='/src/SqlServer.Native.Tests/Snippets/Deduplication/Deduplication.cs#L12-L17' title='Snippet source file'>snippet source</a> | <a href='#snippet-CreateDeduplicationTable' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


#### Delete

The table can be deleted using the following:

<!-- snippet: DeleteDeduplicationTable -->
<a id='snippet-DeleteDeduplicationTable'></a>
```cs
var manager = new DedupeManager(sqlConnection, "DeduplicationTable");
await manager.Drop();
```
<sup><a href='/src/SqlServer.Native.Tests/Snippets/Deduplication/Deduplication.cs#L22-L27' title='Snippet source file'>snippet source</a> | <a href='#snippet-DeleteDeduplicationTable' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


### Sending messages

Sending to the main transport queue with deduplication.


#### Single

Sending a single message with deduplication.

<!-- snippet: SendWithDeduplication -->
<a id='snippet-SendWithDeduplication'></a>
```cs
var manager = new QueueManager(
    "endpointTable",
    sqlConnection,
    "DeduplicationTable");
var message = new OutgoingMessage(
    id: Guid.NewGuid(),
    headers: headers,
    bodyBytes: body);
await manager.Send(message);
```
<sup><a href='/src/SqlServer.Native.Tests/Snippets/Deduplication/Deduplication.cs#L35-L47' title='Snippet source file'>snippet source</a> | <a href='#snippet-SendWithDeduplication' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


#### Batch

Sending a batch of messages with deduplication.

<!-- snippet: SendBatchWithDeduplication -->
<a id='snippet-SendBatchWithDeduplication'></a>
```cs
var manager = new QueueManager(
    "endpointTable",
    sqlConnection,
    "DeduplicationTable");
var messages = new List<OutgoingMessage>
{
    new(
        id: Guid.NewGuid(),
        headers: headers1,
        bodyBytes: body1),
    new(
        id: Guid.NewGuid(),
        headers: headers2,
        bodyBytes: body2),
};
await manager.Send(messages);
```
<sup><a href='/src/SqlServer.Native.Tests/Snippets/Deduplication/Deduplication.cs#L80-L99' title='Snippet source file'>snippet source</a> | <a href='#snippet-SendBatchWithDeduplication' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


### Deduplication cleanup

Deduplication records need to live for a period of time after the initial corresponding message has been send. In this way an subsequent message, with the same message id, can be ignored. This necessitates a periodic cleanup process of deduplication records. This is achieved by using `DeduplicationCleanerJob`:

At application startup, start an instance of `DeduplicationCleanerJob`.

<!-- snippet: DeduplicationCleanerJobStart -->
<a id='snippet-DeduplicationCleanerJobStart'></a>
```cs
var cleaner = new DedupeCleanerJob(
    table: "Deduplication",
    connectionBuilder: cancel =>
        ConnectionHelpers.OpenConnection(connectionString, cancel),
    criticalError: _ => { },
    expireWindow: TimeSpan.FromHours(1),
    frequencyToRunCleanup: TimeSpan.FromMinutes(10));
cleaner.Start();
```
<sup><a href='/src/SqlServer.Native.Tests/Snippets/Deduplication/Deduplication.cs#L53-L64' title='Snippet source file'>snippet source</a> | <a href='#snippet-DeduplicationCleanerJobStart' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->

Then at application shutdown stop the instance.

<!-- snippet: DeduplicationCleanerJobStop -->
<a id='snippet-DeduplicationCleanerJobStop'></a>
```cs
await cleaner.Stop();
```
<sup><a href='/src/SqlServer.Native.Tests/Snippets/Deduplication/Deduplication.cs#L66-L70' title='Snippet source file'>snippet source</a> | <a href='#snippet-DeduplicationCleanerJobStop' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


### JSON headers


#### Serialization

Serialize a `Dictionary<string, string>` to a JSON string.

<!-- snippet: Serialize -->
<a id='snippet-Serialize'></a>
```cs
var headers = new Dictionary<string, string>
{
    {Headers.EnclosedMessageTypes, "SendMessage"}
};
var serialized = Headers.Serialize(headers);
```
<sup><a href='/src/SqlServer.Native.Tests/Snippets/Headers.cs#L9-L17' title='Snippet source file'>snippet source</a> | <a href='#snippet-Serialize' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


#### Deserialization

Deserialize a JSON string to a `Dictionary<string, string>`.

<!-- snippet: Deserialize -->
<a id='snippet-Deserialize'></a>
```cs
var headers = Headers.DeSerialize(headersString);
```
<sup><a href='/src/SqlServer.Native.Tests/Snippets/Headers.cs#L24-L28' title='Snippet source file'>snippet source</a> | <a href='#snippet-Deserialize' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


### Copied header constants

Contains all the string constants copied from `NServiceBus.Headers`.

 
### Duplicated timestamp functionality

A copy of the [timestamp format methods](https://docs.particular.net/nservicebus/messaging/headers#timestamp-format) `ToWireFormattedString` and `ToUtcDateTime`. 


## ConnectionHelpers

The APIs of this extension target either a `SQLConnection` and `SQLTransaction`. Given that in configuration those values are often expressed as a connection string, `ConnectionHelpers` supports converting that string to a `SQLConnection` or `SQLTransaction`. It provides two methods `OpenConnection` and `BeginTransaction` with the effective implementation of those methods being:

<!-- snippet: ConnectionHelpers -->
<a id='snippet-ConnectionHelpers'></a>
```cs
public static async Task<SqlConnection> OpenConnection(
    string connectionString,
    Cancel cancel)
{
    var connection = new SqlConnection(connectionString);
    try
    {
        await connection.OpenAsync(cancel);
        return connection;
    }
    catch
    {
        connection.Dispose();
        throw;
    }
}

public static async Task<SqlTransaction> BeginTransaction(
    string connectionString,
    Cancel cancel)
{
    var connection = await OpenConnection(connectionString, cancel);
    return connection.BeginTransaction();
}
```
<sup><a href='/src/SqlServer.Native.Tests/Snippets/ConnectionHelpers.cs#L3-L30' title='Snippet source file'>snippet source</a> | <a href='#snippet-ConnectionHelpers' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


## SqlServer.HttpPassthrough

SQL HTTP Passthrough provides a bridge between an HTTP stream (via JavaScript on a web page) and the [SQL Server transport](https://docs.particular.net/transports/sql/).

See [docs/http-passthrough.md](docs/http-passthrough.md).


## Icon

[Spear](https://thenounproject.com/term/spear/814550/) designed by [Aldric Rodríguez](https://thenounproject.com/aldricroib2/) from [The Noun Project](https://thenounproject.com/).
