<!--
GENERATED FILE - DO NOT EDIT
This file was generated by [MarkdownSnippets](https://github.com/SimonCropp/MarkdownSnippets).
Source File: /readme.source.md
To change this file edit the source file and then run MarkdownSnippets.
-->

# <img src="/src/icon.png" height="30px"> NServiceBus.SqlServer.Native

[![Build status](https://ci.appveyor.com/api/projects/status/vlhu32bab9gk2olc/branch/master?svg=true)](https://ci.appveyor.com/project/SimonCropp/nservicebus-sqlnative)
[![NuGet Status](https://img.shields.io/nuget/v/NServiceBus.SqlServer.Native.svg?label=SqlServer.Native)](https://www.nuget.org/packages/NServiceBus.SqlServer.Native/)
[![NuGet Status](https://img.shields.io/nuget/v/NServiceBus.SqlServer.HttpPassthrough.svg?label=SqlServer.HttpPassthrough)](https://www.nuget.org/packages/NServiceBus.SqlServer.HttpPassthrough/)
[![NuGet Status](https://img.shields.io/nuget/v/NServiceBus.SqlServer.Deduplication.svg?label=SqlServer.Deduplication)](https://www.nuget.org/packages/NServiceBus.SqlServer.Deduplication/)

SQL Server Transport Native is a shim providing low-level access to the [NServiceBus SQL Server Transport](https://docs.particular.net/transports/sql/) with no NServiceBus or SQL Server Transport reference required.

<!--- StartOpenCollectiveBackers -->

[Already a Patron? skip past this section](#endofbacking)


## Community backed

**It is expected that all developers either [become a Patron](https://opencollective.com/nservicebusextensions/contribute/patron-6976) or have a [Tidelift Subscription](#support-via-tidelift) to use NServiceBusExtensions. [Go to licensing FAQ](https://github.com/NServiceBusExtensions/Home/#licensingpatron-faq)**


### Sponsors

Support this project by [becoming a Sponsor](https://opencollective.com/nservicebusextensions/contribute/sponsor-6972). The company avatar will show up here with a website link. The avatar will also be added to all GitHub repositories under the [NServiceBusExtensions organization](https://github.com/NServiceBusExtensions).


### Patrons

Thanks to all the backing developers. Support this project by [becoming a patron](https://opencollective.com/nservicebusextensions/contribute/patron-6976).

<img src="https://opencollective.com/nservicebusextensions/tiers/patron.svg?width=890&avatarHeight=60&button=false">

<a href="#" id="endofbacking"></a>

<!--- EndOpenCollectiveBackers -->


## Support via TideLift

Support is available via a [Tidelift Subscription](https://tidelift.com/subscription/pkg/nuget-nservicebus.sqlserver.native?utm_source=nuget-nservicebus.sqlserver.native&utm_medium=referral&utm_campaign=enterprise).


<!-- toc -->
## Contents

  * [Usage scenarios](#usage-scenarios)
  * [Main Queue](#main-queue)
    * [Queue management](#queue-management)
    * [Sending messages](#sending-messages)
    * [Reading messages](#reading-messages)
    * [Consuming messages](#consuming-messages)
  * [Delayed Queue](#delayed-queue)
    * [Queue management](#queue-management-1)
    * [Sending messages](#sending-messages-1)
    * [Reading messages](#reading-messages-1)
    * [Consuming messages](#consuming-messages-1)
  * [Headers](#headers)
  * [Subscriptions](#subscriptions)
    * [Table management](#table-management)
  * [Deduplication](#deduplication)
    * [Table management](#table-management-1)
    * [Sending messages](#sending-messages-2)
    * [Deduplication cleanup](#deduplication-cleanup)
    * [JSON headers](#json-headers)
    * [Copied header constants](#copied-header-constants)
    * [Duplicated timestamp functionality](#duplicated-timestamp-functionality)
  * [ConnectionHelpers](#connectionhelpers)
  * [SqlServer.HttpPassthrough](#sqlserverhttppassthrough)
  * [Security contact information](#security-contact-information)<!-- endToc -->


## NuGet packages

 * https://nuget.org/packages/NServiceBus.SqlServer.Native/
 * https://nuget.org/packages/NServiceBus.SqlServer.HttpPassthrough/
 * https://nuget.org/packages/NServiceBus.SqlServer.Deduplication/


## Usage scenarios

 * **Error or Audit queue handling**: Allows to consume messages from error and audit queues, for example to move them to a long-term archive. NServiceBus expects to have a queue per message type, so NServiceBus endpoints are not suitable for processing error or audit queues. SQL Native allows manipulation or consumption of queues containing multiple types of messages.
 * **Corrupted or malformed messages**: Allows to process poison messages which can't be deserialized by NServiceBus. In SQL Native message headers and body are treated as a raw string and byte array, so corrupted or malformed messages can be read and manipulated in code to correct any problems.
 * **Deployment or decommission**: Allows to perform common operational activities, similar to [operations scripts](https://docs.particular.net/transports/sql/operations-scripting#native-send-the-native-send-helper-methods-in-c). Running [installers](https://docs.particular.net/nservicebus/operations/installers) requires starting a full endpoint. This is not always ideal during the execution of a deployment or decommission. SQL Native allows creating or deleting of queues with no running endpoint, and with significantly less code. This also makes it a better candidate for usage in deployment scripting languages like PowerShell.
 * **Bulk operations**: SQL Native supports sending and receiving of multiple messages within a single `SQLConnection` and `SQLTransaction`.
 * **Explicit connection and transaction management**: NServiceBus abstracts the `SQLConnection` and `SQLTransaction` creation and management. SQL Native allows any consuming code to manage the scope and settings of both the `SQLConnection` and `SQLTransaction`.
 * **Message pass through**: SQL Native reduces the amount of boilerplate code and simplifies development.



## Main Queue


### Queue management

Queue management for the [native delayed delivery](https://docs.particular.net/transports/sql/native-delayed-delivery) functionality.

See also [SQL Server Transport - SQL statements](https://docs.particular.net/transports/sql/sql-statements#installation).


#### Create

The queue can be created using the following:

<!-- snippet: CreateQueue -->
<a id='a9166d54'></a>
```cs
var manager = new QueueManager("endpointTable", sqlConnection);
await manager.Create();
```
<sup><a href='/src/SqlServer.Native.Tests/Snippets/Main/MainQueue.cs#L14-L19' title='Snippet source file'>snippet source</a> | <a href='#a9166d54' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


#### Delete

The queue can be deleted using the following:

<!-- snippet: DeleteQueue -->
<a id='ed50e067'></a>
```cs
var manager = new QueueManager("endpointTable", sqlConnection);
await manager.Drop();
```
<sup><a href='/src/SqlServer.Native.Tests/Snippets/Main/MainQueue.cs#L24-L29' title='Snippet source file'>snippet source</a> | <a href='#ed50e067' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


### Sending messages

Sending to the main transport queue.


#### Single

Sending a single message.

<!-- snippet: Send -->
<a id='37ed539c'></a>
```cs
var manager = new QueueManager("endpointTable", sqlConnection);
var message = new OutgoingMessage(
    id: Guid.NewGuid(),
    headers: headers,
    bodyBytes: body);
await manager.Send(message);
```
<sup><a href='/src/SqlServer.Native.Tests/Snippets/Main/MainQueue.cs#L37-L46' title='Snippet source file'>snippet source</a> | <a href='#37ed539c' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


#### Batch

Sending a batch of messages.

<!-- snippet: SendBatch -->
<a id='689573b9'></a>
```cs
var manager = new QueueManager("endpointTable", sqlConnection);
var messages = new List<OutgoingMessage>
{
    new OutgoingMessage(
        id: Guid.NewGuid(),
        headers: headers1,
        bodyBytes: body1),
    new OutgoingMessage(
        id: Guid.NewGuid(),
        headers: headers2,
        bodyBytes: body2),
};
await manager.Send(messages);
```
<sup><a href='/src/SqlServer.Native.Tests/Snippets/Main/MainQueue.cs#L57-L73' title='Snippet source file'>snippet source</a> | <a href='#689573b9' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


### Reading messages

"Reading" a message returns the data from the database without deleting it.


#### Single

Reading a single message.

<!-- snippet: Read -->
<a id='a7afddb6'></a>
```cs
var manager = new QueueManager("endpointTable", sqlConnection);
var message = await manager.Read(rowVersion: 10);

if (message != null)
{
    Console.WriteLine(message.Headers);
    if (message.Body != null)
    {
        using var reader = new StreamReader(message.Body);
        var bodyText = await reader.ReadToEndAsync();
        Console.WriteLine(bodyText);
    }
}
```
<sup><a href='/src/SqlServer.Native.Tests/Snippets/Main/MainQueue.cs#L78-L94' title='Snippet source file'>snippet source</a> | <a href='#a7afddb6' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


#### Batch

Reading a batch of messages.

<!-- snippet: ReadBatch -->
<a id='b0eb71c9'></a>
```cs
var manager = new QueueManager("endpointTable", sqlConnection);
var result = await manager.Read(
    size: 5,
    startRowVersion: 10,
    action: async message =>
    {
        Console.WriteLine(message.Headers);
        if (message.Body == null)
        {
            return;
        }

        using var reader = new StreamReader(message.Body);
        var bodyText = await reader.ReadToEndAsync();
        Console.WriteLine(bodyText);
    });

Console.WriteLine(result.Count);
Console.WriteLine(result.LastRowVersion);
```
<sup><a href='/src/SqlServer.Native.Tests/Snippets/Main/MainQueue.cs#L99-L121' title='Snippet source file'>snippet source</a> | <a href='#b0eb71c9' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


#### RowVersion tracking

For many scenarios, it is likely to be necessary to keep track of the last message `RowVersion` that was read. A lightweight implementation of the functionality is provided by `RowVersionTracker`. `RowVersionTracker` stores the current `RowVersion` in a table containing a single column and row.

<!-- snippet: RowVersionTracker -->
<a id='48682079'></a>
```cs
var versionTracker = new RowVersionTracker();

// create table
await versionTracker.CreateTable(sqlConnection);

// save row version
await versionTracker.Save(sqlConnection, newRowVersion);

// get row version
var startingRow = await versionTracker.Get(sqlConnection);
```
<sup><a href='/src/SqlServer.Native.Tests/Snippets/Main/ProcessingLoop.cs#L20-L33' title='Snippet source file'>snippet source</a> | <a href='#48682079' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->

Note that this is only one possible implementation of storing the current `RowVersion`.


#### Processing loop

For scenarios where continual processing (reading and executing some code with the result) of incoming messages is required, `MessageProcessingLoop` can be used. 

An example use case is monitoring an [error queue](https://docs.particular.net/nservicebus/recoverability/configure-error-handling). Some action should be taken when a message appears in the error queue, but it should remain in that queue in case it needs to be retried. 

Note that in the below snippet, the above `RowVersionTracker` is used for tracking the current `RowVersion`.

<!-- snippet: ProcessingLoop -->
<a id='0f0353e0'></a>
```cs
var rowVersionTracker = new RowVersionTracker();

var startingRow = await rowVersionTracker.Get(sqlConnection);

async Task Callback(
    DbTransaction transaction,
    IncomingMessage message,
    CancellationToken cancellation)
{
    if (message.Body == null)
    {
        return;
    }

    using var reader = new StreamReader(message.Body);
    var bodyText = await reader.ReadToEndAsync();
    Console.WriteLine($"Message received in error message:\r\n{bodyText}");
}

void ErrorCallback(Exception exception)
{
    Environment.FailFast("Message processing loop failed", exception);
}

Task<DbTransaction> TransactionBuilder(CancellationToken cancellation)
{
    return ConnectionHelpers.BeginTransaction(connectionString, cancellation);
}

Task PersistRowVersion(
    DbTransaction transaction,
    long rowVersion,
    CancellationToken token)
{
    return rowVersionTracker.Save(sqlConnection, rowVersion, token);
}

var processingLoop = new MessageProcessingLoop(
    table: "error",
    delay: TimeSpan.FromSeconds(1),
    transactionBuilder: TransactionBuilder,
    callback: Callback,
    errorCallback: ErrorCallback,
    startingRow: startingRow,
    persistRowVersion: PersistRowVersion);
processingLoop.Start();

Console.ReadKey();

await processingLoop.Stop();
```
<sup><a href='/src/SqlServer.Native.Tests/Snippets/Main/ProcessingLoop.cs#L38-L91' title='Snippet source file'>snippet source</a> | <a href='#0f0353e0' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


### Consuming messages

"Consuming" a message returns the data from the database and also deletes that message.


#### Single

Consume a single message.

<!-- snippet: Consume -->
<a id='4bbe204f'></a>
```cs
var manager = new QueueManager("endpointTable", sqlConnection);
var message = await manager.Consume();

if (message != null)
{
    Console.WriteLine(message.Headers);
    if (message.Body != null)
    {
        using var reader = new StreamReader(message.Body);
        var bodyText = await reader.ReadToEndAsync();
        Console.WriteLine(bodyText);
    }
}
```
<sup><a href='/src/SqlServer.Native.Tests/Snippets/Main/MainQueue.cs#L126-L142' title='Snippet source file'>snippet source</a> | <a href='#4bbe204f' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


#### Batch

Consuming a batch of messages.

<!-- snippet: ConsumeBatch -->
<a id='a0c9e297'></a>
```cs
var manager = new QueueManager("endpointTable", sqlConnection);
var result = await manager.Consume(
    size: 5,
    action: async message =>
    {
        Console.WriteLine(message.Headers);
        if (message.Body == null)
        {
            return;
        }

        using var reader = new StreamReader(message.Body);
        var bodyText = await reader.ReadToEndAsync();
        Console.WriteLine(bodyText);
    });

Console.WriteLine(result.Count);
Console.WriteLine(result.LastRowVersion);
```
<sup><a href='/src/SqlServer.Native.Tests/Snippets/Main/MainQueue.cs#L147-L168' title='Snippet source file'>snippet source</a> | <a href='#a0c9e297' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


#### Consuming loop

For scenarios where continual consumption (consuming and executing some code with the result) of incoming messages is required, `MessageConsumingLoop` can be used.

An example use case is monitoring an [audit queue](https://docs.particular.net/nservicebus/operations/auditing). Some action should be taken when a message appears in the audit queue, and it should be purged from the queue to free up the storage space. 

<!-- snippet: ConsumeLoop -->
<a id='21931b02'></a>
```cs
async Task Callback(
    DbTransaction transaction,
    IncomingMessage message,
    CancellationToken cancellation)
{
    if (message.Body != null)
    {
        using var reader = new StreamReader(message.Body);
        var bodyText = await reader.ReadToEndAsync();
        Console.WriteLine($"Reply received:\r\n{bodyText}");
    }
}

Task<DbTransaction> TransactionBuilder(CancellationToken cancellation)
{
    return ConnectionHelpers.BeginTransaction(connectionString, cancellation);
}

void ErrorCallback(Exception exception)
{
    Environment.FailFast("Message consuming loop failed", exception);
}

// start consuming
var consumingLoop = new MessageConsumingLoop(
    table: "endpointTable",
    delay: TimeSpan.FromSeconds(1),
    transactionBuilder: TransactionBuilder,
    callback: Callback,
    errorCallback: ErrorCallback);
consumingLoop.Start();

// stop consuming
await consumingLoop.Stop();
```
<sup><a href='/src/SqlServer.Native.Tests/Snippets/Main/ConsumingLoop.cs#L14-L51' title='Snippet source file'>snippet source</a> | <a href='#21931b02' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


## Delayed Queue


### Queue management

Queue management for the [native delayed delivery](https://docs.particular.net/transports/sql/native-delayed-delivery) functionality.

See also [SQL Server Transport - SQL statements](https://docs.particular.net/transports/sql/sql-statements#create-delayed-queue-table).


#### Create

The queue can be created using the following:

<!-- snippet: CreateDelayedQueue -->
<a id='84435742'></a>
```cs
var manager = new DelayedQueueManager("endpointTable.Delayed", sqlConnection);
await manager.Create();
```
<sup><a href='/src/SqlServer.Native.Tests/Snippets/Delayed/DelayedQueue.cs#L14-L19' title='Snippet source file'>snippet source</a> | <a href='#84435742' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


#### Delete

The queue can be deleted using the following:

<!-- snippet: DeleteDelayedQueue -->
<a id='7c8e323f'></a>
```cs
var manager = new DelayedQueueManager("endpointTable.Delayed", sqlConnection);
await manager.Drop();
```
<sup><a href='/src/SqlServer.Native.Tests/Snippets/Delayed/DelayedQueue.cs#L24-L29' title='Snippet source file'>snippet source</a> | <a href='#7c8e323f' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


### Sending messages


#### Single

Sending a single message.

<!-- snippet: SendDelayed -->
<a id='00915b7c'></a>
```cs
var manager = new DelayedQueueManager("endpointTable.Delayed", sqlConnection);
var message = new OutgoingDelayedMessage(
    due: DateTime.UtcNow.AddDays(1),
    headers: headers,
    bodyBytes: body);
await manager.Send(message);
```
<sup><a href='/src/SqlServer.Native.Tests/Snippets/Delayed/DelayedQueue.cs#L37-L46' title='Snippet source file'>snippet source</a> | <a href='#00915b7c' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


#### Batch

Sending a batch of messages.

<!-- snippet: SendDelayedBatch -->
<a id='262abd80'></a>
```cs
var manager = new DelayedQueueManager("endpointTable.Delayed", sqlConnection);
var messages = new List<OutgoingDelayedMessage>
{
    new OutgoingDelayedMessage(
        due: DateTime.UtcNow.AddDays(1),
        headers: headers1,
        bodyBytes: body1),
    new OutgoingDelayedMessage(
        due: DateTime.UtcNow.AddDays(1),
        headers: headers2,
        bodyBytes: body2),
};
await manager.Send(messages);
```
<sup><a href='/src/SqlServer.Native.Tests/Snippets/Delayed/DelayedQueue.cs#L56-L72' title='Snippet source file'>snippet source</a> | <a href='#262abd80' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


### Reading messages

"Reading" a message returns the data from the database without deleting it.


#### Single

Reading a single message.

<!-- snippet: ReadDelayed -->
<a id='2f18bd22'></a>
```cs
var manager = new DelayedQueueManager("endpointTable", sqlConnection);
var message = await manager.Read(rowVersion: 10);

if (message != null)
{
    Console.WriteLine(message.Headers);
    if (message.Body != null)
    {
        using var reader = new StreamReader(message.Body);
        var bodyText = await reader.ReadToEndAsync();
        Console.WriteLine(bodyText);
    }
}
```
<sup><a href='/src/SqlServer.Native.Tests/Snippets/Delayed/DelayedQueue.cs#L77-L93' title='Snippet source file'>snippet source</a> | <a href='#2f18bd22' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


#### Batch

Reading a batch of messages.

<!-- snippet: ReadDelayedBatch -->
<a id='dc5789a8'></a>
```cs
var manager = new DelayedQueueManager("endpointTable", sqlConnection);
var result = await manager.Read(
    size: 5,
    startRowVersion: 10,
    action: async message =>
    {
        Console.WriteLine(message.Headers);
        if (message.Body == null)
        {
            return;
        }

        using var reader = new StreamReader(message.Body);
        var bodyText = await reader.ReadToEndAsync();
        Console.WriteLine(bodyText);
    });

Console.WriteLine(result.Count);
Console.WriteLine(result.LastRowVersion);
```
<sup><a href='/src/SqlServer.Native.Tests/Snippets/Delayed/DelayedQueue.cs#L98-L120' title='Snippet source file'>snippet source</a> | <a href='#dc5789a8' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


### Consuming messages

"Consuming" a message returns the data from the database and also deletes that message.


#### Single

Consume a single message.

<!-- snippet: ConsumeDelayed -->
<a id='e453207b'></a>
```cs
var manager = new DelayedQueueManager("endpointTable", sqlConnection);
var message = await manager.Consume();

if (message != null)
{
    Console.WriteLine(message.Headers);
    if (message.Body != null)
    {
        using var reader = new StreamReader(message.Body);
        var bodyText = await reader.ReadToEndAsync();
        Console.WriteLine(bodyText);
    }
}
```
<sup><a href='/src/SqlServer.Native.Tests/Snippets/Delayed/DelayedQueue.cs#L125-L141' title='Snippet source file'>snippet source</a> | <a href='#e453207b' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


#### Batch

Consuming a batch of messages.

<!-- snippet: ConsumeDelayedBatch -->
<a id='89c1e56c'></a>
```cs
var manager = new DelayedQueueManager("endpointTable", sqlConnection);
var result = await manager.Consume(
    size: 5,
    action: async message =>
    {
        Console.WriteLine(message.Headers);
        if (message.Body == null)
        {
            return;
        }

        using var reader = new StreamReader(message.Body);
        var bodyText = await reader.ReadToEndAsync();
        Console.WriteLine(bodyText);
    });

Console.WriteLine(result.Count);
Console.WriteLine(result.LastRowVersion);
```
<sup><a href='/src/SqlServer.Native.Tests/Snippets/Delayed/DelayedQueue.cs#L146-L167' title='Snippet source file'>snippet source</a> | <a href='#89c1e56c' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


## Headers

There is a headers helpers class `NServiceBus.Transport.SqlServerNative.Headers`.

It contains several [header](https://docs.particular.net/nservicebus/messaging/headers) related utilities.


## Subscriptions

Queue management for the [native publish subscribe](https://docs.particular.net/transports/sql/native-publish-subscribe) functionality.


### Table management


#### Create

The table can be created using the following:

<!-- snippet: CreateSubscriptionTable -->
<a id='61d295bf'></a>
```cs
var manager = new SubscriptionManager("SubscriptionRouting", sqlConnection);
await manager.Create();
```
<sup><a href='/src/SqlServer.Native.Tests/Snippets/Subscription/Subscription.cs#L11-L16' title='Snippet source file'>snippet source</a> | <a href='#61d295bf' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


#### Delete

The table can be deleted using the following:

<!-- snippet: DeleteSubscriptionTable -->
<a id='60132678'></a>
```cs
var manager = new SubscriptionManager("SubscriptionRouting", sqlConnection);
await manager.Drop();
```
<sup><a href='/src/SqlServer.Native.Tests/Snippets/Subscription/Subscription.cs#L21-L26' title='Snippet source file'>snippet source</a> | <a href='#60132678' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


## Deduplication

Some scenarios, such as HTTP message pass through, require message deduplication.


### Table management


#### Create

The table can be created using the following:

<!-- snippet: CreateDeduplicationTable -->
<a id='997bb523'></a>
```cs
var manager = new DedupeManager(sqlConnection, "DeduplicationTable");
await manager.Create();
```
<sup><a href='/src/SqlServer.Native.Tests/Snippets/Deduplication/Deduplication.cs#L14-L19' title='Snippet source file'>snippet source</a> | <a href='#997bb523' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


#### Delete

The table can be deleted using the following:

<!-- snippet: DeleteDeduplicationTable -->
<a id='cea50afc'></a>
```cs
var manager = new DedupeManager(sqlConnection, "DeduplicationTable");
await manager.Drop();
```
<sup><a href='/src/SqlServer.Native.Tests/Snippets/Deduplication/Deduplication.cs#L24-L29' title='Snippet source file'>snippet source</a> | <a href='#cea50afc' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


### Sending messages

Sending to the main transport queue with deduplication.


#### Single

Sending a single message with deduplication.

<!-- snippet: SendWithDeduplication -->
<a id='d76f503f'></a>
```cs
var manager = new QueueManager(
    "endpointTable",
    sqlConnection,
    "DeduplicationTable");
var message = new OutgoingMessage(
    id: Guid.NewGuid(),
    headers: headers,
    bodyBytes: body);
await manager.Send(message);
```
<sup><a href='/src/SqlServer.Native.Tests/Snippets/Deduplication/Deduplication.cs#L37-L49' title='Snippet source file'>snippet source</a> | <a href='#d76f503f' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


#### Batch

Sending a batch of messages with deduplication.

<!-- snippet: SendBatchWithDeduplication -->
<a id='44f978e1'></a>
```cs
var manager = new QueueManager(
    "endpointTable",
    sqlConnection,
    "DeduplicationTable");
var messages = new List<OutgoingMessage>
{
    new OutgoingMessage(
        id: Guid.NewGuid(),
        headers: headers1,
        bodyBytes: body1),
    new OutgoingMessage(
        id: Guid.NewGuid(),
        headers: headers2,
        bodyBytes: body2),
};
await manager.Send(messages);
```
<sup><a href='/src/SqlServer.Native.Tests/Snippets/Deduplication/Deduplication.cs#L84-L103' title='Snippet source file'>snippet source</a> | <a href='#44f978e1' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


### Deduplication cleanup

Deduplication records need to live for a period of time after the initial corresponding message has been send. In this way an subsequent message, with the same message id, can be ignored. This necessitates a periodic cleanup process of deduplication records. This is achieved by using `DeduplicationCleanerJob`:

At application startup, start an instance of `DeduplicationCleanerJob`.

<!-- snippet: DeduplicationCleanerJobStart -->
<a id='2f7febaa'></a>
```cs
var cleaner = new DedupeCleanerJob(
    table: "Deduplication",
    connectionBuilder: cancellation =>
    {
        return ConnectionHelpers.OpenConnection(connectionString, cancellation);
    },
    criticalError: exception => { },
    expireWindow: TimeSpan.FromHours(1),
    frequencyToRunCleanup: TimeSpan.FromMinutes(10));
cleaner.Start();
```
<sup><a href='/src/SqlServer.Native.Tests/Snippets/Deduplication/Deduplication.cs#L55-L68' title='Snippet source file'>snippet source</a> | <a href='#2f7febaa' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->

Then at application shutdown stop the instance.

<!-- snippet: DeduplicationCleanerJobStop -->
<a id='da192f4f'></a>
```cs
await cleaner.Stop();
```
<sup><a href='/src/SqlServer.Native.Tests/Snippets/Deduplication/Deduplication.cs#L70-L74' title='Snippet source file'>snippet source</a> | <a href='#da192f4f' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


### JSON headers


#### Serialization

Serialize a `Dictionary<string, string>` to a JSON string.

<!-- snippet: Serialize -->
<a id='8b98a923'></a>
```cs
var headers = new Dictionary<string, string>
{
    {Headers.EnclosedMessageTypes, "SendMessage"}
};
var serialized = Headers.Serialize(headers);
```
<sup><a href='/src/SqlServer.Native.Tests/Snippets/Headers.cs#L9-L17' title='Snippet source file'>snippet source</a> | <a href='#8b98a923' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


#### Deserialization

Deserialize a JSON string to a `Dictionary<string, string>`.

<!-- snippet: Deserialize -->
<a id='59df4159'></a>
```cs
var headers = Headers.DeSerialize(headersString);
```
<sup><a href='/src/SqlServer.Native.Tests/Snippets/Headers.cs#L24-L28' title='Snippet source file'>snippet source</a> | <a href='#59df4159' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


### Copied header constants

Contains all the string constants copied from `NServiceBus.Headers`.

 
### Duplicated timestamp functionality

A copy of the [timestamp format methods](https://docs.particular.net/nservicebus/messaging/headers#timestamp-format) `ToWireFormattedString` and `ToUtcDateTime`. 


## ConnectionHelpers

The APIs of this extension target either a `SQLConnection` and `SQLTransaction`. Given that in configuration those values are often expressed as a connection string, `ConnectionHelpers` supports converting that string to a `SQLConnection` or `SQLTransaction`. It provides two methods `OpenConnection` and `BeginTransaction` with the effective implementation of those methods being:

<!-- snippet: ConnectionHelpers -->
<a id='c2a35b25'></a>
```cs
public static async Task<DbConnection> OpenConnection(
    string connectionString,
    CancellationToken cancellation)
{
    var connection = new SqlConnection(connectionString);
    try
    {
        await connection.OpenAsync(cancellation);
        return connection;
    }
    catch
    {
        connection.Dispose();
        throw;
    }
}

public static async Task<DbTransaction> BeginTransaction(
    string connectionString,
    CancellationToken cancellation)
{
    var connection = await OpenConnection(connectionString, cancellation);
    return connection.BeginTransaction();
}
```
<sup><a href='/src/SqlServer.Native.Tests/Snippets/ConnectionHelpers.cs#L8-L35' title='Snippet source file'>snippet source</a> | <a href='#c2a35b25' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


## SqlServer.HttpPassthrough

SQL HTTP Passthrough provides a bridge between an HTTP stream (via JavaScript on a web page) and the [SQL Server transport](https://docs.particular.net/transports/sql/).

See [docs/http-passthrough.md](docs/http-passthrough.md).


## Security contact information

To report a security vulnerability, use the [Tidelift security contact](https://tidelift.com/security). Tidelift will coordinate the fix and disclosure.


## Icon

[Spear](https://thenounproject.com/term/spear/814550/) designed by [Aldric Rodríguez](https://thenounproject.com/aldricroib2/) from [The Noun Project](https://thenounproject.com/).
